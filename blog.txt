OAuth 2.0 has become the industry standard for secure, token-based authentication. It’s used by major tech companies, social media platforms, and financial institutions to grant users secure access without sharing passwords. Its flexibility and scalability make it ideal for modern applications.

In this post, I’ll walk through how to implement OAuth 2.0 in a Tauri application, bridging the world of web-based authentication with native desktop apps.
Understanding OAuth 2.0

OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, like GitHub, Google, or Facebook. OAuth operates by granting tokens rather than exposing user passwords, significantly enhancing security.
OAuth Flow:

    Authorization Request: The application requests permission from the user.
    User Authorization: The user authenticates and grants permissions.
    Redirect with Code: OAuth server redirects the user to the application with a code.
    Exchange Code for Token: The application exchanges this code for an access token.
    Access Protected Resources: The token is used to access protected resources.

The Backend

to first integrate OAuth into our tauri application, we are going to use tauri-plugin-oauth library, a powerful plugin by Fabian Lars that simplifies OAuth implementation in Tauri apps. We are also going to use reqwest and url to Makes HTTP requests to OAuth provider (GitHub) and parse the url query parameters.

1. The verify Function

use tauri::{Window,Emitter};
use reqwest::Client;
use tauri_plugin_oauth::{OauthConfig, start_with_config};
use url::Url;

fn verify(url: &str, expected_state: &str) -> Option<String> {
    let url = Url::parse(url).ok()?;
    if url.path() != "/callback" { return None; }

    let mut code = None;
    let mut ok   = false;
    for (k, v) in url.query_pairs() {
        match &*k {
            "code"  => code = Some(v.into_owned()),
            "state" => ok   = v == expected_state,
            _ => {}
        }
    }
    code.filter(|_| ok)
}

This function handles your OAuth provider’s redirect application after the user has Authenticated. First parsing the URL query to extract the OAuth “code” and “state” which will be used to later obtain an access token and prevent CSRF attacks respectively.

2. The start_oauth Command

#[tauri::command]
async fn start_oauth(window: Window, state: String) -> Result<u16, String> {
    let cfg = OauthConfig {
        ports: Some(vec![8000, 8001, 8002]),     // Multiple ports to avoid conflicts
        response: Some("OAuth finished. You may close this tab.".into()),
    };

    start_with_config(cfg, move |url| {
        if let Some(code) = verify(&url, &state) {
            let _ = window.emit("github_code", code);
        }
    }).map_err(|e| e.to_string())
}

Here we are initializing the local OAuth HTTP server and listening to specific ports, here I have them listed but you can also set the port dynamically. We listen for redirects from Github and after successful authorization we utilize the verify function to ensure a valid OAuth redirect. Finally, once verified, the function emits a github code event letting the frontend know it can proceed to the next OAuth step, exchanging the code for an access token.

3. The exchange_code Command

#[tauri::command]
async fn exchange_code(code: String, client_id: String, client_secret: String)
    -> Result<String, String>
{
    let resp = Client::new()
        .post("https://github.com/login/oauth/access_token")
        .header("Accept", "application/json")
        .form(&[
            ("client_id", client_id),
            ("client_secret", client_secret),
            ("code", code),
        ])
        .send().await.map_err(|e| e.to_string())?
        .json::<serde_json::Value>().await.map_err(|e| e.to_string())?;

    resp["access_token"].as_str()
        .map(String::from)
        .ok_or("no token".into())
}

This last function sends an HTTP POST request to GitHub’s OAuth API, including the authorization code along with the application’s GitHub OAuth app credentials (client_id and client_secret), receives the JSON response from GitGub containing the access_token and subsequently extracts and returns the token to the frontend.
The Frontend

Without going into as much details as I did for the backend, I will explain how the frontend calls the backend functions to not only access the token but securly store it as well. Also important to note, all the functions below are stored in a ts file that can be called by my login.tsx page which I found to be a better seperation of concerns.
1. Token Management Functions

These functions interact with Tauri’s Keychain plugin to store tokens securely on the user’s machine:

export const saveToken = (t: string) => saveItem(KEY, t);
export const loadToken = () => getItem(KEY).catch(() => null);
export const wipeToken = () => removeItem(KEY).catch(() => {});

    saveToken: Stores the OAuth token securely.
    loadToken: Retrieves the stored token; returns null if none exists.
    wipeToken: Removes the token from secure storage when logging out or if the token becomes invalid.

Why needed?
Securely storing and retrieving the token prevents unnecessary re-authentication and protects sensitive user data.
2. checkExistingToken

This function checks if a previously saved token still provides valid GitHub API access:

export async function checkExistingToken(): Promise<string | null> {
  const token = await loadToken();
  if (!token) return null;

  const ok = await fetch("https://api.github.com/user", {
    headers: { Authorization: `token ${token}` }
  }).then(r => r.ok);

  if (!ok) {
    await wipeToken();
    return null;
  }
  return token;
}

    Attempts to load an existing token from secure storage.
    Checks validity by calling GitHub’s user endpoint with the token.
    If GitHub returns a non-success status (invalid or expired token), removes the token and returns null.
    If valid, the token is returned and can be used for further authenticated requests.

Why needed?
This prevents unnecessary OAuth flows by reusing previously acquired tokens so that the user doesn’t need to constantly authenticate.
3. loginWithGitHub

Initiates the OAuth authentication flow with GitHub:

export async function loginWithGitHub() {
  const state = randomState();
  const port  = await invoke<number>("start_oauth", { state });

  const stop = await listen<string>("github_code", async ({ payload }) => {
    stop();  // stop listening after receiving the event
    const token: string = await invoke("exchange_code", {
      code: payload,
      clientId: CLIENT_ID,
      clientSecret: CLIENT_SECRET,
    });
    await saveToken(token);
    window.location.reload();
  });

  const redirect = `http://localhost:${port}/callback`;
  const url = "https://github.com/login/oauth/authorize?" +
    new URLSearchParams({
      client_id: CLIENT_ID,
      redirect_uri: redirect,
      scope: "repo read:org",
      state,
    });

  await open(url);
}

    Generates a random OAuth state value to securely track the request (protects against CSRF attacks).
    Calls the Tauri backend (start_oauth) to start a local OAuth server.
    Listens for a custom github_code event emitted by your Rust backend upon receiving GitHub’s OAuth redirect.
    Opens GitHub’s OAuth authorization URL in the user’s browser, requesting permissions (repo, read:org scopes) If you need other permissions check GitHub’s docs.
    After user authorization, GitHub redirects back to your local OAuth server.
    Backend extracts the OAuth code and emits it via the github_code event.
    Frontend listens, receives the code, exchanges it for an access token using backend (exchange_code).
    The received access token is stored securely (saveToken), then the page is reloaded to reflect authenticated state.

4. ensureAuth (Authentication Check)

export async function ensureAuth(): Promise<string | null> {
  const token = await loadToken();
  if (!token) {
    await loginWithGitHub();
    return null;
  }

  const ok = await fetch("https://api.github.com/user", {
    headers: { Authorization: `token ${token}` }
  }).then(r => r.ok);

  if (!ok) {
    await wipeToken();
    await loginWithGitHub();
    return null;
  }
  return token;
}

    Checks if a token exists. If not, initiates OAuth login flow.
    Verifies token validity. If invalid, clears it and triggers OAuth flow again.
    Ensures the user has an authenticated session before proceeding with sensitive operations.

5. Logout Function

Clears the token from storage and resets application state:

export async function logout() {
  await wipeToken();
  window.location.href = "/";
}

    Deletes the stored token.
    Redirects user to the login screen.

Final words

With this code you will be able to implement your own OAuth2 implementation with token usage and refresh for your Tauri app. Although this implementation was built with Github in mind, using other providers such as google, is a similar flow. If you think there is anything missing or something that could be better optimized please reach out.
